BeginPackage["CommandLineParser`"];

ParseCommandLine;

NumericSpec;
StringSpec;
BooleanSpec;
EnumSpec;
RepeatedSpec;

ParseCommandLine::usage = "ParseCommandLine[spec, args] parses the list of string arguments args according to the specification spec. 
ParseCommandLine[spec] automatically gets the arguments from the command line call.";

NumericSpec::usage = "NumericSpec[type, docString] generates a specification for a number. The value returned by the parser is either a number or +/- Infinity.
* type is either \"Real\" or \"Integer\"
* docString is the documentation string for the argument
* Can set the option \"Interval\" -> {a, b} to specify an allowed interval (endpoints allowed). Can use Infinity for unbounded intervals
* Can set the option \"AllowInfinity\" -> True to actually allow Infinity or -Infinity as input values (or their lower-cased equivalents). They will be parsed to their equivalent symbolic expressions
* Can set the option \"Variadic\" -> True to make it variadic";
StringSpec::usage = "StringSpec[docString] generates a specification for a string that is taken verbatim from the command line. No transformation or check is performed.
* docString is the documentation string for the argument
* Can set the option \"Variadic\" -> True to make it variadic";
BooleanSpec::usage = "BooleanSpec[docString] generates a specification for a boolean. The value returned by the parser is either the True or False symbol, and command line input can be True, False or their lower-cased equivalents
* docString is the documentation string for the argument
* Can set the option \"Variadic\" -> True to make it variadic";
EnumSpec::usage = "EnumSpec[values, docString] generates a specification for an argument having values that range on a fixed set of choices. The value returned by the parser is anything appearing in values, and lower-cased names are accepted as command line inputs. Essentially, BooleanSpec is an EnumSpec with values True and False
* values is the list of desired values. Both symbols and strings can be used
* docString is the documentation string for the argument";
RepeatedSpec::usage = "RepeatedSpec[singleSpec, separator, docString] generates a specification for a list of values each specified by singleSpec. It has a similar use to a variadic argument but has the advantage that any number of arguments like this can be specified while only one argument can be variadic. Values must be separated using the separator with no spaces, and the elements are collected into a list. It is possible to create an empty list by just passing separator as the argument value, or by --opt-name= for optional arguments.
* singleSpec is the specification for the individual elements. It can be an explicit low-level specification or it can be generated by other high-level helpers. Each of the provided elements are parsed individually according to singleSpec
* separator is a string of one or more characters used to separate individual values. It cannot be a whitespace
* docString is the documentation string for the argument. The documentation string of singleSpec is ignored";

Begin["`Private`"];

(******************************************************************)
(***************************** PARSER *****************************)
(******************************************************************)

ParseCommandLine[allSpecs_] := ParseCommandLine[allSpecs, getCommandLineArgs[]]
ParseCommandLine[{pos_, opts_}, args_] := ParseCommandLine[{pos, opts, ""}, args]
ParseCommandLine[spec_, $Failed] := (
	Message[ParseCommandLine::clfail];
	Abort[];
)

ParseCommandLine[{posSpecsRaw_, optSpecsRaw_, helpHeader_}, args_] := Module[
	{posSpecs, optSpecs, optPos, posArgs, optArgs, posParsed, optsParsed},
	If[!MatchQ[args, {RepeatedNull[_?StringQ]}],
		Message[ParseCommandLine::nostring];
		Abort[];
	];
	checkRawSpecs[{posSpecsRaw, optSpecsRaw}];
	{posSpecs, optSpecs} = {toSpec /@ posSpecsRaw, toSpec /@ optSpecsRaw};
	If[MemberQ[args, "--help"],
		printHelp @@ {posSpecs, optSpecs, helpHeader};
		Exit[0]
	];

	optPos = First @ FirstPosition[
		args, 
		_?(StringQ[#] && StringStartsQ[#, "--"]&), 
		{Length[args] + 1}
	];
	{posArgs, optArgs} = TakeDrop[args, optPos - 1];

	posParsed = parsePosArgs[posSpecs, posArgs];
	optsParsed = parseOptArgs[optSpecs, optArgs];

	{posParsed, optsParsed}
];

checkRawSpecs[{args_, opts_}] := Module[{variadicPos, hasVariadic, split, test},
	If[!ListQ[args],
		Message[ParseCommandLine::badspec, "Positional", args];
		Abort[]		
	];
	If[!ListQ[opts],
		Message[ParseCommandLine::badspec, "Optional", opts];
		Abort[]		
	];
	Scan[checkRawSpec[#, False]&, args];
	Scan[checkRawSpec[#, True]&, opts];
	(* Only the last pos argument can be variadic and it must not have a default *)
	variadicPos = Flatten @ Position[args[[All, 2, 4]], True];
	Which[
		Developer`EmptyQ[variadicPos],
			hasVariadic = False,
		Or[
			Length[variadicPos] > 1,
			Length[variadicPos] === 1 && variadicPos =!= {Length[args]}
		],
			Message[ParseCommandLine::badvariadic1];
			Abort[],
		True,
			hasVariadic = True
	];
	(* Check position of positional arguments with optional values *)
	If[MemberQ[args, {_, _} -> _],
		split = Split[args, Length[First[#1]] === Length[First[#2]] &];
		test = If[hasVariadic,
			getLengths[split] === {0, 2, 0}|{2, 0},
			getLengths[split] === {0, 2}|{2}
		];
		If[!test,
			Message[ParseCommandLine::badposdef];
			Abort[]
		]
	]
];

getLengths[split_] := Flatten @ Map[DeleteDuplicates] @ Map[Length, split[[All, All, 1]], {2}]

checkRawSpec[spec:Rule[name_, data_], isOpt_] := Module[
	{patt, parser, check, hasVariadic, doc, pattCheck},
	If[Length[data] =!= 5,
		Message[ParseCommandLine::badspec, If[isOpt, "Optional", "Positional"], spec];
		Abort[]
	];
	{patt, parser, check, hasVariadic, doc} = data;
	(* We check is patt is a valid string pattern by just using it in StringMatchQ *)
	pattCheck = Quiet[
		Check[StringMatchQ["xxx", patt], $Failed, StringExpression::invld],
		StringExpression::invld
	];
	If[
		Or[
			!MatchQ[name, {_?StringQ, _?StringQ} | _?StringQ],
			FailureQ[pattCheck],
			!MatchQ[parser, _Function],
			!MatchQ[check, _Function],
			!BooleanQ[hasVariadic],
			!StringQ[doc]
		],
		Message[ParseCommandLine::badspec, If[isOpt, "Optional", "Positional"], spec];
		Abort[]		
	];
	Which[
		hasVariadic && MatchQ[name, {_?StringQ, _?StringQ}],
			Message[ParseCommandLine::badvariadic2];
			Abort[],
		isOpt && !hasVariadic && MatchQ[name, _?StringQ],
			Message[ParseCommandLine::badspec, "Optional", spec];
			Abort[]			
	];
];
checkRawSpec[spec_, isOpt_] := (
	Message[ParseCommandLine::badspec, If[isOpt, "Optional", "Positional"], spec];
	Abort[]
)

toSpec[name_ -> data_] := Apply[toSpec, Prepend[data, name]]
toSpec[name_, patt_, parser_, postCheck_, variadic_, doc_] := Module[
	{name2, default, res},
	{name2, default} = Replace[name, {l_List :> l, s_ :> {s, $NotProvided}}];
	<|
		"Name" -> name2, 
		"StringPattern" -> patt, 
		"Documentation" -> doc, 
		"Parser" -> parser, 
		"PostCheck" -> postCheck, 
		"Variadic" -> variadic,
		"Default" -> default
	|>
]

parsePosArgs[specs_, posArgs_] := Module[
	{hasVariadic, nOptional, nMandatory, posArgs2, specs2, parsed, most, variadic},
	hasVariadic = If[Length[specs] > 0,
		specs[[-1, "Variadic"]],
		False
	];
	nOptional = Count[specs, KeyValuePattern @ {"Default" -> Except[$NotProvided]}];
	nMandatory = Length[specs] - nOptional - If[hasVariadic, 1, 0];
	If[
		Or[
			hasVariadic && !(nMandatory <= Length[posArgs]),
			!hasVariadic && !(nMandatory <= Length[posArgs] <= nMandatory + nOptional)
		],
		Message[ParseCommandLine::poslen, Length[posArgs], nMandatory,
			If[hasVariadic, "infinity", nMandatory + nOptional]];
		Abort[]
	];
	(* Add defaults *)
	posArgs2 = If[Length[posArgs] < Length[specs] && nOptional > 0,
		Join[
			posArgs,
			Take[specs, {Length[posArgs] + 1, If[hasVariadic, -2, -1]}][[All, "Default"]]
		],
		posArgs
	];
	(* This can shorten the specs in case the variadic has length 0 *)
	specs2 = If[hasVariadic,
		PadRight[specs, Length[posArgs2], Last[specs]],
		specs
	];
	parsed = MapThread[parseSingle, {specs2, posArgs2, Range @ Length[specs2]}];
	If[hasVariadic,
		{most, variadic} = TakeDrop[parsed, Length[specs] - 1];
		parsed = Append[most, variadic]
	];
	AssociationThread[specs[[All, "Name"]], parsed]
]

parseOptArgs[specs_, optArgs_] := Module[{provided, unknown, values, parsed, spec},
	provided = StringReplace[optArgs, 
		{
			"--" ~~ name__ ~~ "=" ~~ val___ :> {name, val},
			"--" ~~ name__ :> {name, "True"},
			_ :> (Message[ParseCommandLine::badopts, optArgs]; Abort[];)
		}
	][[All, 1]];
	provided = Rule @@@ provided;
	(* ^ {optName -> val, ...} optName can be duplicated *)
	If[!Developer`EmptyQ[unknown = Complement[Keys @ provided, specs[[All, "Name"]]]],
		Message[ParseCommandLine::unkopt, unknown];
		Abort[]
	];
	parsed = Flatten @ Map[
		Function[
			values = Cases[provided, HoldPattern[#Name -> val_] :> val];
			Which[
				values === {} && #Variadic,
					{#Name -> $lenZeroVariadic}, (* inhert special symbol *)
				values === {},
					{#Name -> parseSingle[#, #Default, None]},
				True,
					Table[#Name -> parseSingle[#, v, None], {v, values}]
			]
		],
		specs
	];
	parsed = GroupBy[parsed, First, Values];
	(* For variadic options aggregate all passed values into a list, for non variadic take the
	   last provided value. *)
	parsed = Association @ KeyValueMap[
		Function[
			spec = FirstCase[specs, KeyValuePattern @ {"Name" -> #1}];
			#1 -> Replace[spec["Variadic"], {True -> #2, False -> Last[#2]}]
		],
		parsed
	];
	Replace[parsed, {$lenZeroVariadic} -> {}, {1}]
];

parseSingle[spec_, arg_, pos_] := Module[{parsed},
	If[Not @ StringMatchQ[arg, spec["StringPattern"]],
		Message[ParseCommandLine::nomatch, 
			Replace[pos, {None -> "Optional", _ -> "Positional"}], 
			argNameWithPos[spec["Name"], pos], 
			arg, 
			spec["Documentation"]
		];
		Abort[]
	];
	parsed = spec["Parser"][arg];
	If[Not @ TrueQ @ spec["PostCheck"][parsed],
		Message[ParseCommandLine::failcheck, 
			Replace[pos, {None -> "Optional", _ -> "Positional"}], 
			argNameWithPos[spec["Name"], pos], 
			parsed, 
			spec["Documentation"]
		];
		Abort[]
	];
	parsed
];

argNameWithPos[name_, pos_] := StringJoin[
	name,
	Replace[pos, {None -> "", n_ :> StringJoin[" (position ", ToString[n], ")"]}]
]

getCommandLineArgs[] := Module[{pos},
	Which[
		!Developer`EmptyQ[$ScriptCommandLine],
			Rest[$ScriptCommandLine],
		!Developer`EmptyQ[$CommandLine],
			pos = FirstPosition[$CommandLine, "-script"];
			If[MissingQ[pos],
				$Failed,
				$CommandLine[[First[pos] + 2 ;; -1]]
			],
		True,
			$Failed
	]
];

printHelp[posSpecs_, optSpecs_, helpHeader_] := Module[{mandatoryPos, optionalPos, varOpt},
	If[helpHeader =!= "",
		Print[helpHeader];
	];
	mandatoryPos = Extract[
		posSpecs,
		Position[posSpecs, KeyValuePattern @ {"Default" -> $NotProvided, "Variadic" -> False}]
	];
	optionalPos = Extract[
		posSpecs,
		Position[posSpecs, 
			Alternatives[
				KeyValuePattern @ {"Default" -> Except[$NotProvided]},
				KeyValuePattern @ {"Variadic" -> True}
			]
		]
	];
	If[!Developer`EmptyQ[mandatoryPos],
		Print[];
		Print["* Mandatory positional arguments:"];
		printArgTableColumns[mandatoryPos, {"Name", "Documentation"}]
	];
	If[!Developer`EmptyQ[optionalPos],
		Print[];
		Print["* Optional positional arguments (must be passed in this order after the mandatory arguments):"];		
		printArgTableColumns[optionalPos, {"Name", "Default", "Documentation"}];
		If[optionalPos[[-1, "Variadic"]],
			Print[];
			Print["Argument " <> optionalPos[[-1, "Name"]] <> " is variadic."]
		]
	];
	If[!Developer`EmptyQ[optSpecs],
		Print[];
		Print["* Optional arguments (must be passed as --name=... in any order):"];			
		printArgTableColumns[optSpecs, {"Name", "Default", "Documentation"}];
		varOpt = Cases[optSpecs, a:KeyValuePattern @ {"Variadic" -> True} :> a["Name"]];
		If[varOpt =!= {},
			Print[];
			Print["The following options are variadic: " <> ToString[varOpt]];
		]
	];
]

printArgTableColumns[specs_, keys_] := Module[{columns, most, maxWidths, padded},
	columns = Transpose @ Prepend[Lookup[specs, keys], ToUpperCase[keys]];
	most = Replace[Most[columns], $NotProvided -> "{}", {2}];
	maxWidths = Max /@ Map[StringLength, most, {2}];
	padded = MapThread[StringPadRight, {most, maxWidths}];
	Scan[Print[StringRiffle[#, "    "]]&, Transpose @ Append[padded, Last[columns]]];
]

(******************************************************************)
(************************** SPEC HELPERS **************************)
(******************************************************************)

Options[NumericSpec] = {
	"Interval" -> {-Infinity, Infinity},
	"AllowInfinity" -> False,
	"Variadic" -> False
};
NumericSpec[type_, doc_, OptionsPattern[]] := Module[
	{interval, allowInf, patt, parser, checks, postCheck},
	{interval, allowInf} = {OptionValue["Interval"], OptionValue["AllowInfinity"]};
	patt = If[allowInf, 
		Alternatives[NumberString, "infinity", "Infinity", "-infinity", "-Infinity"],
		NumberString
	];
	parser = Function @ Replace[#, 
		{
			"infinity"|"Infinity" -> Infinity,
			"-infinity"|"-Infinity" -> -Infinity,
			n_ :> ToExpression[n]
		}
	];

	checks = With[{interval = interval},
		{IntervalMemberQ[Interval[interval], #]&}
	];
	Which[
		type === "Integer" && allowInf,
			AppendTo[checks, 
				Function[IntegerQ[#] || MatchQ[#, DirectedInfinity[-1|1]]]
			],
		type === "Integer",
			AppendTo[checks, Function[IntegerQ[#]]]
	];
	postCheck = With[{checks = checks}, Function[{val}, And @@ Map[#[val]&, checks]]];

	{patt, parser, postCheck, OptionValue["Variadic"], doc}
];

Options[StringSpec] = {"Variadic" -> False};
StringSpec[doc_, OptionsPattern[]] := {___, #&, True&, OptionValue["Variadic"], doc}

Options[BooleanSpec] = {"Variadic" -> False};
BooleanSpec[doc_, OptionsPattern[]] := {
	"true"|"false"|"True"|"False",
	Function[Replace[#, {"true"|"True" -> True, "false"|"False" -> False}]],
	True&,
	OptionValue["Variadic"],
	doc
}

Options[EnumSpec] = {"Variadic" -> False};
EnumSpec[values_, doc_, OptionsPattern[]] := Module[
	{replacements, patt, parser, specDoc, outputDoc},
	replacements = Map[
		With[{s = ToString[#]},
			Apply[Alternatives, {s, ToLowerCase[s]}] -> #
		]&,
		values
	];
	patt = Alternatives @@ Keys[replacements];
	parser = With[{r = replacements}, Function[Replace[#, r]]];
	{patt, parser, True&, OptionValue["Variadic"], doc}
]

RepeatedSpec[singleSpec_, separator_, doc_] := Module[
	{singlePatt, singleParser, singleCheck},
	{singlePatt, singleParser, singleCheck} = singleSpec[[1 ;; 3]];
	{
		(RepeatedNull[singlePatt ~~ separator] ~~ singlePatt) | separator | "",
		With[{p = singleParser}, 
			Function[Map[p, StringSplit[#, separator]]]
		],
		With[{c = singleCheck}, Function[And @@ Map[c, #]]],
		False,
		doc
	}
]

$helpMsg = "Please add the flag --help for documentation.";
ParseCommandLine::badopts = "Optional arguments were not correctly formatted: ``.";
ParseCommandLine::badspec = "`` argument specification `` is not valid.";
ParseCommandLine::badposdef = "Invalid positional argument specification: positional arguments without defaults should appear before the ones with defaults. Only a single variadic argument can appear after.";
ParseCommandLine::badvariadic1 = "Invalid argument specification: only one positional argument can be variadic and must appear as the end of the positional argument specification.";
ParseCommandLine::badvariadic2 = "Invalid argument specification: variadic arguments cannot have a default. If nothing is passed they automatically default to an empty list.";
ParseCommandLine::clfail = "Could not access the command line.";
ParseCommandLine::failcheck = "`` argument `` was parsed to ``, which is an invalid value. Documentation string for the argument is: \"``\".";
ParseCommandLine::nomatch = "`` argument `` was ``, which is an invalid value. Documentation string for the argument is: \"``\".";
ParseCommandLine::nostring = "Provided argument list was not a list of strings.";
ParseCommandLine::poslen = "`` positional arguments were passed but specification requires between `` and ``. " <> $helpMsg;
ParseCommandLine::unkopt = "Unknown options ``. " <> $helpMsg;

End[];
EndPackage[];